# -*- coding: utf-8 -*-
"""CaliforniaHousingPricesData

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1BJ2XSM9mP9KH5sNNFpm7UQedCNvLgJfj
"""
from turtle import color
import pandas as pd
import numpy as np
from sklearn.preprocessing import LabelEncoder
import seaborn as sns
import matplotlib.pyplot as plt
import plotly.express as px
from seaborn import colors
from seaborn.palettes import color_palette
from scipy import stats
from sklearn.model_selection import train_test_split
from sklearn import linear_model
from sklearn.metrics import mean_squared_error
from sklearn.metrics import mean_absolute_error
from sklearn.metrics import r2_score
from sklearn.metrics import classification_report,confusion_matrix
from sklearn.ensemble import RandomForestRegressor


class CaliforniaHousingData:
  ''' This class consists of functions related to reading file and displaying the data'''

  # Read Housing File
  def read_Housing_File(filepath):
    try:
      housingData = pd.read_csv(filepath)
    except IOError as err:
      print("Error: can\'t find file or read data. \nDetailed error is {}".format(err))
    else:
      print ("California Housing Prices File read successfully")
      return housingData

 
  
  # Displaying first 5 data of Housing File
  def get_Housing_HeadData(housingData):
    try:
      return housingData.head()
    except:
      print("Error showing the data.")
  

class HousingPriceData:
  '''Functions to work on obtained Dataframe to check for Column Information, Null values, Duplicates'''

  # -- California House Prices Dataset --

  # Get Column Information for Housing Dataset
  def get_HousingData_Info(housingData):
    try:
      return housingData.info()
    except:
      print("Unable to fetch Housing Data Information.")
  
  # Check for the Null value in Housing Dataset
  def get_HousingData_NullValues(housingData):
    try:
      return housingData.isnull().sum()
    except:
      print("Unable to print Housing Data Null values.")

  def drop_HousingData_NullValues(housingData):
      try:
        return housingData.dropna(inplace=True)
      except:
        print("Unable to drop Housing Data Null values.")

  # Drop the Null value in Housing Dataset
  def get_Housingdata_DropDuplicates(housingData):
    try:
      return housingData.drop_duplicates()
    except:
      print("Unable to drop Housing Data duplicate values.")
  
  # Getting the unique value from text filed
  def get_Housingdata_UniqueValueInTextField(housingData):
    try:
      return housingData['ocean_proximity'].unique()
    except:
      print("Unable to drop Housing Data duplicate values.")

  # Fetching all the columns of dataframe
  def get_Housingdata_Columns(housingData):
    try:
      return housingData.columns
    except:
      print("Unable to fetch Housing Data columns.")

  # Converting text value to numerical value for classification
  def set_housingData_TexttoNumerical(housingData):
    try:
      distProximity = {'NEAR BAY':0, '<1H OCEAN':1, 'INLAND':2, 'NEAR OCEAN':3, 'ISLAND':4}
      housingData['ocean_proximity'] = housingData.ocean_proximity.map(distProximity)
      housingData['ocean_proximity'].unique()
    except:
      print("Unable to convert Text data into Numerical format")
  

# ------------ EDA SECTION ----------------

class HousingDataEDA:

  # ---- Pair Plot ----
  def get_HousingData_Pairplot(housingData):
    try:
      sns.pairplot(housingData, hue = 'ocean_proximity', palette ='Set1' )
    except:
      print("Unable to print Housing Data Pairplot")

  # ---- Pair Plot [median_income]----
  def get_Pairplot_MedianIncome(housingData):
    try:
      plt.figure()
      cols_to_plot = housingData.columns[7:10].tolist() # explicitly add the column "Outcome" to your list of columns to plot
      sns.pairplot(housingData[cols_to_plot], hue ="ocean_proximity")
      plt.show()
    except:
      print("Unable to print Housing Data Pairplot")

  # ---- Scatter Mapbox ----
  def get_HousingData_Mapbox(housingData):
    try:
      figure = px.scatter_mapbox(housingData, lat="latitude", lon="longitude", hover_name="ocean_proximity",
      color_discrete_sequence=["red"], zoom=5, height=300)
      figure.update_layout(mapbox_style="open-street-map")
      figure.update_layout(margin={"r":0,"t":0,"l":0,"b":0})
      figure.show()
    except:
      print("Unable to print Mapbox")
  
  # ---- Normal Distribution ----
  def get_HousingData_ND(housingData):
    try:
      fig, axes = plt.subplots(2, 3, figsize=(10, 10), sharey=True)
      plt.subplots_adjust(bottom=0.1, right=1.2, top=1.)

      columns = ["housing_median_age", "total_rooms", "total_bedrooms", "population","households", "median_income"]

      count = 0

      for i in range(6):
        ax = plt.subplot(2, 3, count+1, title=columns[count])
        stats.probplot(housingData[columns[count]], dist="norm", plot=plt)
        ax.set_title(columns[count])
        ax.get_lines()[0].set_marker('p')
        ax.get_lines()[0].set_markerfacecolor('m')
        ax.get_lines()[0].set_markersize(15.0)
        ax.relim()
        count += 1
      plt.show()
    except:
      print(" Unable to plot the Normal Distribution")

  # ---- Outlier Check ----
  def get_HousingData_Outlier(housingData):
    try:
      for column in housingData:
        plt.figure()
        sns.boxplot(x=housingData[column])
    except:
      print("Unable to display Outliers")
  
  # ---- Drop the outliers ----
  def drop_HousingData_Outlier_andPlot(housingData,columns):
    try:
      quantile1 = housingData[columns].quantile(0.25)
      quantile3 = housingData[columns].quantile(0.75)
      IQR = quantile3 - quantile1

      new_DataFrame = housingData[~((housingData[columns] < (quantile1 - (1.5 * IQR))) |(housingData[columns] > (quantile3 + (1.5 * IQR)))).any(axis=1)]


      fig, axes = plt.subplots(2, 3, figsize=(10, 10), sharey=True)
      plt.subplots_adjust(bottom=0.1, right=1.2, top=1.)

      count = 0
      for i in range(6):
          ax = plt.subplot(2, 3, count+1, title=columns[count])
          
          stats.probplot(new_DataFrame[columns[count]], dist="norm", plot=plt)
          ax.set_title(columns[count])
          ax.get_lines()[0].set_marker('p')
          ax.get_lines()[0].set_markerfacecolor('y')
          ax.get_lines()[0].set_markersize(15.0)
          count += 1

      plt.show()
    except:
      print("Unable to display Normal Distrinution")
  

  # ---- Heat Map ----
  def get_HousingData_Heatmap(housingData):
    try:
      housingData[['median_house_value','longitude','latitude','housing_median_age','total_rooms', 'total_bedrooms',
       'population', 'households','median_income','ocean_proximity']]
      map = plt.figure(figsize =(15,8))
      sns.heatmap(housingData.corr(),annot= True)
    except:
      print("Unable to display Heat Map")

  def get_CM_Heatmap(cm_train):
    try:
      plt.figure(figsize=(10,10))
      sns.heatmap(cm_train, annot=True, fmt=".0f", linewidths=.2, square = True);
      plt.ylabel('Actual label');
      plt.xlabel('Predicted label');
    except:
      print('Unable to print Confusion matrix Heatmap')


# ----- Algorithm check on the dataset -----
class HousingDataAlgorithmTest:

  # ---- Testing and training the data in the ratio [60-40]
  def get_DataSplit(housingData):
    try:
      train, test = train_test_split(housingData, test_size=0.4, random_state=101)
      x_train = train[train.columns.difference(['median_house_value'])]
      y_train = train["median_house_value"]

      x_test = test[test.columns.difference(['median_house_value'])]
      y_test = test["median_house_value"]

      return x_train, y_train, x_test, y_test
    except:
      print("error while trying to test and train the data")

  
  # ---- Linear Regression ----
  def get_LinearRegression_Fit(x_train, y_train):
    try:
      linearReg_Model = linear_model.LinearRegression()
      linearReg_Model.fit(x_train, y_train)
    except:
      print("Error performing the fit operation on the model")


  # ---- Get the MSE and MAE Data ----
  def get_MSE_MAE(x_test,y_test,linearReg_Model):
    try:
      y_pred_lr = linearReg_Model.predict(x_test)
      figure, a = plt.subplots()
      a.scatter(y_test, y_pred_lr)
      a.plot([y_test.min(), y_test.max()], [y_test.min(), y_test.max()], 'r-', lw=2)

      print("Mean Squared Error: ", mean_squared_error(y_test, y_pred_lr))
      print("Mean Absolute Error: ", mean_absolute_error(y_test, y_pred_lr))
    except:
      print("Unable to fetch Mean Squared Error and Mean Absolute Error")


  # ---- Get the Confusion Matrix ----
  def get_ConfusionMatrix(y_test,predictions):
    try:
      cm_train = confusion_matrix(y_test,predictions)
      print(confusion_matrix(y_test,predictions))
    except:
      print('Unable to print the confusion matrix')
  
  # ---- Plot Median Income Linear Regression
  def plot_medianIncome_LR(x_testIncome,y_predict):
    try:
      scaledDFrame.plot(kind='scatter',x='median_income',y='median_house_value')
      plt.plot(x_testIncome,y_predict,c='red',linewidth=3)
    except:
      print('Unable to plot Linear Regression plot for Median Income field')

  # ---- Fitting the data in Random Forest 
  def get_RandomForest_Fit(x_train,y_train):
    try:
      rfc = RandomForestRegressor(n_estimators=100)
      rfc.fit(x_train, y_train)
    except:
      print('Unable to fit the Random Forest, check x_train and y_train')
  
  # ---- Fitting the data in Decision Tree 
  def get_DecisionTree_Fit(x_train,y_train,dtregressor):
    try:
      dtregressor.fit(x_train, y_train)
    except:
      print('Unable to fit the Random Forest, check x_train and y_train')
  

  # ---- Random Forest R2 / MSE 
  def get_RandomForest_R2andMSE(x_test,rfc,y_test):
    try:
      y_predict = rfc.predict(x_test)
      print(np.sqrt(mean_squared_error(y_test,y_predict)))
      print((r2_score(y_test,y_predict)))
    except:
      print('Unable to fit the Random Forest, check x_train and y_train')
  
  # ---- Random Forest R2 / MSE 
  def get_DecisionTree_R2andMSE(x_test,y_test,dtregressor):
    try:
      y_predict = dtregressor.predict(x_test)
      print(f'RMSE {np.sqrt(mean_squared_error(y_test,y_predict))}')
      print(r2_score(y_test, y_predict))
    except:
      print('Unable to fit the Random Forest, check x_train and y_train')

  # ---- Plot Total Rooms Linear Regression
  def plot_TotalRooms_LR(x_testRooms,y_predict,scaledDFrame):
    try:
      scaledDFrame.plot(kind='scatter',x='median_income',y='median_house_value')
      plt.plot(x_testRooms,y_predict,c='red',linewidth=3)
    except:
      print('Unable to plot Linear Regression plot for Total Rooms field')
  
  
  

  
  

  
 